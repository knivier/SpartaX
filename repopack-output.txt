This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-02-02T16:22:26.537Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
src/
  ai.py
  characters.py
  engine.py
  imaging.py
  main.py
  particles.py
  Player_List.py
  Player.py
  sounds.py
  spritesheet.py
.gitignore
LICENSE
properties.yaml
README.md
requirements.txt

================================================================
Repository Files
================================================================

================
File: src/ai.py
================
import os
import random
import yaml


class wizard_bot:
    def __init__(self):
        def loadDifficulty():
            try:
                yaml_path = os.path.join(
                    os.path.dirname(__file__), "../properties.yaml"
                )
                with open(yaml_path, "r") as file:
                    properties = yaml.safe_load(file)
                    difficulty = properties.get("base_options", {}).get("difficulty", 2)
                    health_base = (
                        properties.get("game_options", {})
                        .get("ai", {})
                        .get("health", 0)
                    )
                    attack_base = (
                        properties.get("game_options", {})
                        .get("ai", {})
                        .get("attack", 0)
                    )
                    mana_base = (
                        properties.get("game_options", {}).get("ai", {}).get("mana", 0)
                    )
            except FileNotFoundError:
                difficulty = 2
            return [difficulty, health_base, attack_base, mana_base]

        self.difficulty = loadDifficulty()[0]
        self.health = loadDifficulty()[1] + (self.difficulty * 10)
        self.mana = loadDifficulty()[2] + (self.difficulty * 10)
        self.attack = loadDifficulty()[3] + (self.difficulty + 10)
        self.state = ""

    def get_attack(self):
        return self.attack

    def set_attack(self, value):
        self.attack = value

    def get_mana(self):
        return self.mana

    def get_health(self):
        return self.health

    def set_mana(self, value):
        self.mana += value
        if self.mana < 0:
            self.mana = 0

    def set_health(self, value):
        self.health += value
        if self.health < 0:
            self.health = 0

    def set_state(self, state2):
        self.state = state2

    def get_state(self):
        return self.state

    def has_enough_mana(self, value):
        return self.mana >= value


def wizard_bot_turn(bot, player):
    # safety
    if bot.difficulty < 0:
        bot.difficulty = 0
    if bot.difficulty > 5:
        bot.difficulty = 5
    # easy/medium mode
    if bot.difficulty <= 3:
        number = random.randint(1, 5)
        if number == 1:
            bot.set_state("Resting")
        elif number == 2:
            bot.set_state("Attacking")
        elif number == 3:
            bot.set_state("Defending")
        elif number == 4:
            bot.set_state("Healing")
        else:
            bot.set_state("Special Attack")
        return bot.get_state()
    # FSM - finite state machine to determine the wizard's action
    if bot.get_mana() == 0:
        bot.set_state("Resting")
    elif player.get_health() <= bot.get_attack() and bot.has_enough_mana(10):
        bot.set_state("Attacking")
    elif bot.get_health() <= player.get_attack() and bot.has_enough_mana(20):
        bot.set_state("Defending")
    elif bot.get_health() <= 30 and bot.has_enough_mana(30):
        bot.set_state("Healing")
    else:
        bot.set_state("Attack")
    return bot.get_state()

================
File: src/characters.py
================
import pygame

class CharacterSprite(pygame.sprite.Sprite):
    def __init__(self, image_paths, pos, animation_speed=0.1):
        """
        image_paths: List of paths to images representing animation frames.
        pos: Initial position of the sprite.
        animation_speed: Controls the speed of the animation.
        """
        super().__init__()
        self.frames = [pygame.image.load(img).convert_alpha() for img in image_paths]
        self.current_frame = 0
        self.animation_speed = animation_speed
        self.image = self.frames[self.current_frame]
        self.rect = self.image.get_rect(center=pos)
        self.animation_timer = 0  # Track animation time

    def update(self, delta_time):
        # Update animation based on elapsed time
        self.animation_timer += delta_time
        if self.animation_timer >= self.animation_speed:
            self.animation_timer = 0
            self.current_frame = (self.current_frame + 1) % len(self.frames)
            self.image = self.frames[self.current_frame]

    def reset_animation(self):
        self.current_frame = 0
        self.image = self.frames[self.current_frame]

================
File: src/engine.py
================
import random
import pygame
from particles import ParticleEffect

from Player_List import (
    Draco,
    Hydra,
    Phoenix,
    Lyra,
    Orion,
    Pegasus,
    Andromeda,
    Centaurus,
    Cassiopeia,
)
import imaging
import yaml
import os
import cv2  # For color conversion
import logging
import time
import ai
import sounds
import spritesheet

# Ensure Pygame is initialized before anything else
pygame.init()
pygame.font.init()  # Explicitly initialize the font module

# Game Constants
ROUND_TIME = 60  # Total time for the entire battle (seconds)
TURN_TIME = 5  # Each turn lasts 5 seconds

# Set up logging
logging.basicConfig(
    filename="logs.log",
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s",
)

# Log new session
logging.info(f"NEW SESSION ID: {time.time()}")


def calculate_defense_efficiency():
    """Return a tuple (fully_efficient, reduction).
    - fully_efficient is True 50% of the time.
    - If not fully efficient, reduction is between 40% and 80% (as a fraction)."""
    fully_efficient = random.choice([True, False])
    reduction = random.uniform(0.4, 0.8)
    logging.debug(
        f"Defense efficiency calculated: fully_efficient={fully_efficient}, reduction={reduction}"
    )
    return fully_efficient, reduction


class LogWindow:
    def __init__(self, rect):
        """
        rect: pygame.Rect defining where the log is drawn on the GUI surface.
        """
        self.rect = rect
        self.font = pygame.font.Font(None, 24)
        self.messages = []
        self.max_lines = 20
        logging.debug("LogWindow initialized")

    def add_message(self, message):
        self.messages.append(message)
        if len(self.messages) > self.max_lines:
            self.messages.pop(0)
        logging.debug(f"Message added to LogWindow: {message}")

    def update(self, surface):
        # Draw a background for the log area.
        pygame.draw.rect(surface, (30, 30, 30), self.rect)
        y = self.rect.y + 10
        for message in self.messages:
            text_surface = self.font.render(message, True, (255, 255, 255))
            surface.blit(text_surface, (self.rect.x + 10, y))
            y += 30
        logging.debug("LogWindow updated")


class GameEngine:
    def __init__(self, player1, player2):
        self.player1 = player1
        self.player2 = player2
        # Create a display of 1368x720.
        self.screen = pygame.display.set_mode((1368, 720))
        # self.screen = pygame.display.get_surface()
        # pygame.display.set_caption("Wizard Duel")
        self.clock = pygame.time.Clock()
        self.running = True

        # Set up a dedicated GUI surface for the right half.
        # Right half occupies x = 684 to 1368.
        self.gui_surface = pygame.Surface((1368 // 2, 720))
        # Positions for health/mana bars (relative to the GUI surface).
        self.p1_health_rect = pygame.Rect(16, 50, 200, 20)
        self.p1_mana_rect = pygame.Rect(16, 80, 200, 20)
        self.p2_health_rect = pygame.Rect(16, 150, 200, 20)
        self.player1_action = "Idle"  # Default action state
        self.player2_action = "Idle"  # Default action state
        self.p2_mana_rect = pygame.Rect(16, 180, 200, 20)
        # Log window area on the GUI surface.
        self.log_rect = pygame.Rect(16, 250, 652, 400)
        self.log_window = LogWindow(self.log_rect)
        logging.debug("GameEngine initialized")
        
        self.sprite_manager = spritesheet.SpriteManager()
        self.sound_manager = sounds.SoundManager()

    def update_camera_view(self):
        """
        Update the left half of the window with the latest camera frame.
        Assumes that imaging.to_window (global) is a BGR numpy array.
        """
        try:
            if imaging.to_window is not None:
                # Convert BGR to RGB.
                frame_rgb = cv2.cvtColor(imaging.to_window, cv2.COLOR_BGR2RGB)
                # Create a Pygame surface from the numpy array.
                frame_surface = pygame.surfarray.make_surface(frame_rgb.swapaxes(0, 1))
                # Scale frame to fill the left half (684x720).
                frame_surface = pygame.transform.scale(frame_surface, (684, 720))
                self.screen.blit(frame_surface, (0, 0))
                logging.debug("Camera view updated with new frame")
            else:
                pygame.draw.rect(self.screen, (0, 0, 0), (0, 0, 684, 720))
                logging.debug("Camera view updated with black screen")
        except pygame.error as e:
            logging.error(f"Pygame error in update_camera_view: {e}")

    def update_gui(self):
        """
        Draw the GUI on the right half: background, health/mana bars, and log window.
        """
        self.particle_effects = []
        self.gui_surface.fill((50, 50, 50))
        # Draw health/mana bars for player1.
        p1_health_width = int((self.player1.get_health() / 100) * 200)
        pygame.draw.rect(
            self.gui_surface,
            (255, 0, 0),
            (
            self.p1_health_rect.x,
            self.p1_health_rect.y,
            p1_health_width,
            self.p1_health_rect.height,
            ),
        )
        # Draw player1's name above the health bar
        player1_name_surface = self.log_window.font.render(self.player1.get_name(), True, (255, 255, 255))
        self.gui_surface.blit(player1_name_surface, (self.p1_health_rect.x, self.p1_health_rect.y - 25))
        p1_mana_width = int((self.player1.get_mana() / 100) * 200)
        pygame.draw.rect(
            self.gui_surface,
            (0, 0, 255),
            (
                self.p1_mana_rect.x,
                self.p1_mana_rect.y,
                p1_mana_width,
                self.p1_mana_rect.height,
            ),
        )
        
        # Add health number for player1
        health_text = self.log_window.font.render(f"Health: {self.player1.get_health()}", True, (255, 255, 255))
        self.gui_surface.blit(health_text, (226, 50))
        
        # Draw health/mana bars for player2.
        p2_health_width = int((self.player2.get_health() / 100) * 200)
        pygame.draw.rect(
            self.gui_surface,
            (255, 0, 0),
            (
            self.p2_health_rect.x,
            self.p2_health_rect.y,
            p2_health_width,
            self.p2_health_rect.height,
            ),
        )
        # Draw player2's name above the health bar
        player2_name_surface = self.log_window.font.render(self.player2.get_name(), True, (255, 255, 255))
        self.gui_surface.blit(player2_name_surface, (self.p2_health_rect.x, self.p2_health_rect.y - 25))
        p2_mana_width = int((self.player2.get_mana() / 100) * 200)
        pygame.draw.rect(
            self.gui_surface,
            (0, 0, 255),
            (
            self.p2_mana_rect.x,
            self.p2_mana_rect.y,
            p2_mana_width,
            self.p2_mana_rect.height,
            ),
        )
        
        # Add health number for player2
        health_text2 = self.log_window.font.render(f"Health: {self.player2.get_health()}", True, (255, 255, 255))
        self.gui_surface.blit(health_text2, (226, 150))
        
        # Update log window on the GUI surface
        self.log_window.update(self.gui_surface)

        # Blit the GUI surface onto the right half of the main screen
        self.screen.blit(self.gui_surface, (684, 0))
        
        p1_sprite = self.sprite_manager.get_sprite(self.player1.get_name(), self.player1_action)
        p2_sprite = self.sprite_manager.get_sprite(self.player2.get_name(), self.player2_action)
        
        if p1_sprite:
            self.sprite_surface.blit(p1_sprite, (20, 20))
        if p2_sprite:
            self.sprite_surface.blit(p2_sprite, (120, 20))
            
        # Play sounds based on actions
        if self.player1_action in ['Attack', 'Heal', 'Special']:
            self.sound_manager.play_sound(self.player1_action)
        if self.player2_action in ['Attack', 'Heal', 'Special']:
            self.sound_manager.play_sound(self.player2_action)

    # Update the display
        pygame.display.update()
        logging.debug("GUI updated")

    def log(self, message):
        """Add a message to the log window."""
        self.log_window.add_message(message)
        logging.info(message)

    def process_round_moves(self, move1, move2):
        """
        Process both players' moves concurrently.
        move1: move chosen by player1 ("Attack", "Defending", "Resting", "Healing", "Special Attack")
        move2: move chosen by player2 ("Attack", "Defending", "Resting", "Healing", "Special Attack")
        """
        logging.debug(
            f"Processing moves: {self.player1.get_name()} -> {move1}, {self.player2.get_name()} -> {move2}"
        )
        # Process player1's move.
        if move1 == "Attack":
            pygame.display.update()
            if self.player1.get_mana() >= 20:
                self.player1.set_mana(self.player1.get_mana() - 20)
                if move2 == "Defending":
                    damage = self.player1.get_attack() - self.player2.get_defense()
                    if damage < 0:
                        damage = 0
                    fully_efficient, reduction = calculate_defense_efficiency()
                    if fully_efficient:
                        damage = 0
                        self.log(
                            f"{self.player2.get_name()} defended fully against {self.player1.get_name()}'s attack!"
                        )
                    else:
                        damage = int(damage * (1 - reduction))
                        self.log(
                            f"{self.player2.get_name()} defended inefficiently, reducing damage by {int(reduction * 100)}%!"
                        )
                elif move2 == "Resting":
                    damage = int(self.player1.get_attack() * 1.5)
                elif move2 == "Attacking":
                    damage = self.player1.get_attack()
                else:
                    damage = self.player1.get_attack()
                self.player2.set_health(self.player2.get_health() - damage)
                self.log(
                    f"{self.player1.get_name()} attacks {self.player2.get_name()} for {damage} damage!"
                )
            else:
                self.log(
                    f"{self.player1.get_name()} tried to attack but didn't have enough mana!"
                )
        elif move1 == "Defending":
            if self.player1.get_mana() >= 20:
                self.player1.set_mana(self.player1.get_mana() - 20)
                self.log(f"{self.player1.get_name()} is defending this turn!")
            else:
                self.log(
                    f"{self.player1.get_name()} tried to defend but didn't have enough mana!"
                )
        elif move1 == "Resting":
            mana_gain = random.randint(20, 35)
            self.player1.set_mana(self.player1.get_mana() + mana_gain)
            self.log(f"{self.player1.get_name()} rests and gains {mana_gain} mana!")
        elif move1 == "Healing":
            if self.player1.get_mana() >= 30:
                self.player1.set_mana(self.player1.get_mana() - 30)
                health_gain = random.randint(15, 30)
                self.player1.set_health(self.player1.get_health() + health_gain)
                self.log(f"{self.player1.get_name()} heals and gains {health_gain} health!")
            else:
                self.log(
                    f"{self.player1.get_name()} tried to heal but didn't have enough mana!"
                )
        elif move1 == "Special Attack":
            if self.player1.get_mana() >= 50:
                self.player1.set_mana(self.player1.get_mana() - 50)
                damage = self.player1.get_attack() * 2
                self.player2.set_health(self.player2.get_health() - damage)
                self.log(
                    f"{self.player1.get_name()} uses a special attack on {self.player2.get_name()} for {damage} damage!"
                )
            else:
                self.log(
                    f"{self.player1.get_name()} tried to use a special attack but didn't have enough mana!"
                )

        # Process player2's move.
        if move2 == "Attack":
            
            pygame.display.update()
            if self.player2.get_mana() >= 20:
                self.player2.set_mana(self.player2.get_mana() - 20)
                if move1 == "Defending":
                    damage = self.player2.get_attack() - self.player1.get_defense()
                    if damage < 0:
                        damage = 0
                    fully_efficient, reduction = calculate_defense_efficiency()
                    if fully_efficient:
                        damage = 0
                        self.log(
                            f"{self.player1.get_name()} defended fully against {self.player2.get_name()}'s attack!"
                        )
                    else:
                        damage = int(damage * (1 - reduction))
                        self.log(
                            f"{self.player1.get_name()} defended inefficiently, reducing damage by {int(reduction * 100)}%!"
                        )
                elif move1 == "Resting":
                    damage = int(self.player2.get_attack() * 1.5)
                elif move1 == "Attacking":
                    damage = self.player2.get_attack()
                else:
                    damage = self.player2.get_attack()
                self.player1.set_health(self.player1.get_health() - damage)
                self.log(
                    f"{self.player2.get_name()} attacks {self.player1.get_name()} for {damage} damage!"
                )
            else:
                self.log(
                    f"{self.player2.get_name()} tried to attack but didn't have enough mana!"
                )
        elif move2 == "Defending":
            if self.player2.get_mana() >= 20:
                self.player2.set_mana(self.player2.get_mana() - 20)
                self.log(f"{self.player2.get_name()} is defending this turn!")
            else:
                self.log(
                    f"{self.player2.get_name()} tried to defend but didn't have enough mana!"
                )
        elif move2 == "Resting":
            mana_gain = random.randint(20, 35)
            self.player2.set_mana(self.player2.get_mana() + mana_gain)
            self.log(f"{self.player2.get_name()} rests and gains {mana_gain} mana!")
        elif move2 == "Healing":
            if self.player2.get_mana() >= 30:
                self.player2.set_mana(self.player2.get_mana() - 30)
                health_gain = random.randint(15, 30)
                self.player2.set_health(self.player2.get_health() + health_gain)
                self.log(f"{self.player2.get_name()} heals and gains {health_gain} health!")
            else:
                self.log(
                    f"{self.player2.get_name()} tried to heal but didn't have enough mana!"
                )
        elif move2 == "Special Attack":
            if self.player2.get_mana() >= 50:
                self.player2.set_mana(self.player2.get_mana() - 50)
                damage = self.player2.get_attack() * 2
                self.player1.set_health(self.player1.get_health() - damage)
                self.log(
                    f"{self.player2.get_name()} uses a special attack on {self.player1.get_name()} for {damage} damage!"
                )
            else:
                self.log(
                    f"{self.player2.get_name()} tried to use a special attack but didn't have enough mana!"
                )

    def battle_round(self, single_player=False, bot=None):
        """
        Main battle loop.
        For every TURN_TIME seconds, imaging.scan() is used to get both players' moves.
        The moves are processed, and both the camera view and GUI are updated.
        """
        logging.debug("Starting battle round")
        # Get moves from imaging.scan (blocks for TURN_TIME seconds).
        moves = imaging.scan(TURN_TIME, single_player)
        logging.debug(f"Scanned moves: {moves}")
        if not single_player:
            move_p1, move_p2 = moves
            self.player1_action = move_p1
            self.player2_action = move_p2
        else:
            move_p1 = moves
            self.player1_action = moves
            if bot is None:
                logging.error("Bot is not defined in single player mode")
                raise ValueError("Bot is not defined in single player mode")
            move_p2 = ai.wizard_bot_turn(bot, self.player1)

        self.log(
            f"Moves this turn: {self.player1.get_name()} -> {move_p1}, {self.player2.get_name()} -> {move_p2}"
        )

        self.process_round_moves(move_p1, move_p2)

        # Update display: left half (camera) and right half (GUI).
        self.update_camera_view()
        self.update_gui()
        pygame.display.update()
        self.clock.tick(30)
        logging.debug("Battle round completed")

    def declare_winner(self):
        if self.player1.get_health() > self.player2.get_health():
            self.log(f"{self.player1.get_name()} wins!")
        elif self.player2.get_health() > self.player1.get_health():
            self.log(f"{self.player2.get_name()} wins!")
        else:
            self.log("It's a draw!")
        logging.info("Game ended, winner declared")
        # Keep the window open after the game ends until the user quits.
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    logging.info("Game window closed by user")
                    return
            self.update_camera_view()
            self.update_gui()
            pygame.display.update()
            self.clock.tick(30)

    def gameOver(self):
        if self.player1.get_health() <= 0 or self.player2.get_health() <= 0:
            logging.debug("Game over condition met")
            return True
        return False


def run():
    # Load configuration from YAML.
    yaml_path = os.path.join(os.path.dirname(__file__), "../properties.yaml")
    with open(yaml_path, "r") as file:
        properties = yaml.safe_load(file)
    logging.debug("Configuration loaded from YAML")

    player1_name = properties.get("game_options", {}).get("player1", {}).get("name")
    player2_name = properties.get("game_options", {}).get("player2", {}).get("name")
    if player1_name is None:
        logging.error("player1 is not specified in properties.yaml")
        raise ValueError("player1 is not specified in properties.yaml")
    if player2_name is None:
        logging.error("player2 is not specified in properties.yaml")
        raise ValueError("player2 is not specified in properties.yaml")

    single_player = properties.get("base_options", {}).get("mode") == "player_vs_ai"
    bot = None
    if single_player:
        bot = ai.wizard_bot()

    player_classes = {
        "Draco": Draco,
        "Hydra": Hydra,
        "Phoenix": Phoenix,
        "Lyra": Lyra,
        "Orion": Orion,
        "Pegasus": Pegasus,
        "Andromeda": Andromeda,
        "Centaurus": Centaurus,
        "Cassiopeia": Cassiopeia,
    }
    p1_class = player_classes.get(player1_name)
    p2_class = player_classes.get(player2_name)
    if p1_class is None:
        logging.error(f"Unknown player1: {player1_name}")
        raise ValueError(f"Unknown player1: {player1_name}")
    if p2_class is None:
        logging.error(f"Unknown player2: {player2_name}")
        raise ValueError(f"Unknown player2: {player2_name}")

    game = GameEngine(p1_class(), p2_class())
    logging.info("GameEngine instance created")
    while not game.gameOver():
        game.battle_round(single_player=single_player, bot=bot)
        pygame.time.wait(5000)
        # ? Logic for pausing game and resuming to let user see stats

    game.declare_winner()


if __name__ == "__main__":
    run()

================
File: src/imaging.py
================
import cv2
import pygame
import mediapipe as mp
from mediapipe.tasks import python
from mediapipe.tasks.python import vision
from mediapipe.framework.formats import landmark_pb2
import numpy as np
import threading

WIDTH, HEIGHT = 1920, 1080
"""Width and height of the Pygame screen"""
MIN_DETECTION_CONFIDENCE = 0.75
"""Confidence level required to establish a pose detection"""
MIN_TRACKING_CONFIDENCE = 0.8
"""Confidence level required to establish pose tracking"""
MIN_PRESENCE_CONFIDENCE = 0.7
"""Confidence level required to establish a pose presence"""
TORSO_LENGTH_ARM_RATIO = 0.35
"""Ratio of the torso length to the arm length"""
SOLO_PLAY = False
"""Whether the player is playing alone"""
NUM_POSES = 2
"""Number of poses to detect"""
MODEL_PATH_ALT = "/Users/ankur/Coding-Projects/Hackathon/SpartahackX/SpartaX/src/pose_landmarker_full.task"
MODEL_PATH = "/Users/ammar/Desktop/ec/hackathons/spartahackX_good/SpartaX/src/pose_landmarker_full.task"

# MODEL_PATH = "./src/pose_landmarker_full.task"
"""Path to the pose landmarker model"""

# pygame.init()
# cap = cv2.VideoCapture(0)
# cap.set(cv2.CAP_PROP_FRAME_WIDTH, WIDTH)
# cap.set(cv2.CAP_PROP_FRAME_HEIGHT, HEIGHT)
# screen = pygame.display.set_mode((WIDTH, HEIGHT))
# pygame.display.set_caption("WizViz Pose Detection")

to_window = None
last_timestamp_ms = 0
detection_result = None


def print_result(
    result: vision.PoseLandmarkerResult,  # type: ignore
    output_image: mp.Image,
    timestamp_ms: int,
):
    global to_window
    global last_timestamp_ms
    global detection_result
    if timestamp_ms < last_timestamp_ms:
        return
    last_timestamp_ms = timestamp_ms
    detection_result = result
    to_window = cv2.cvtColor(
        draw_landmarks_on_image(output_image.numpy_view(), detection_result),
        cv2.COLOR_RGB2BGR,
    )


def get_player_number(pose_landmarks):
    nose_pose_x = pose_landmarks[mp.solutions.pose.PoseLandmark.NOSE].x
    player_number = 0

    if nose_pose_x == 0:
        return 0

    if SOLO_PLAY:
        return 1

    if nose_pose_x < 0.5:
        player_number = 1
    else:
        player_number = 2

    return player_number


def define_action(pose_landmarks):
    right_wrist = pose_landmarks[mp.solutions.pose.PoseLandmark.RIGHT_WRIST]
    left_wrist = pose_landmarks[mp.solutions.pose.PoseLandmark.LEFT_WRIST]

    right_shoulder = pose_landmarks[mp.solutions.pose.PoseLandmark.RIGHT_SHOULDER]
    left_shoulder = pose_landmarks[mp.solutions.pose.PoseLandmark.LEFT_SHOULDER]

    right_hip = pose_landmarks[mp.solutions.pose.PoseLandmark.RIGHT_HIP]
    left_hip = pose_landmarks[mp.solutions.pose.PoseLandmark.LEFT_HIP]

    if right_shoulder.x == 0:
        human_center_x = left_shoulder.x
    elif left_shoulder.x == 0:
        human_center_x = right_shoulder.x
    else:
        human_center_x = np.average([right_shoulder.x, left_shoulder.x])

    if right_hip.y == 0:
        torso_length = np.abs(left_hip.y - left_shoulder.y)
    elif left_hip.y == 0:
        torso_length = np.abs(right_hip.y - right_shoulder.y)
    else:
        torso_length = np.average(
            [
                np.abs(right_hip.y - right_shoulder.y),
                np.abs(left_hip.y - left_shoulder.y),
            ]
        )

    player_number = get_player_number(pose_landmarks)
    player_move = "Resting"
    
    # print(f"Right wrist visibility: {right_wrist.visibility}")
    # print(f"Left wrist visibility: {left_wrist.visibility}")
    # print(f"Right shoulder visibility: {right_shoulder.visibility}")
    # print(f"Left shoulder visibility: {left_shoulder.visibility}")
    # print(f"Right hip visibility: {right_hip.visibility}")
    # print(f"Left hip visibility: {left_hip.visibility}")
    
    if (
        right_wrist.visibility == 0
        or left_wrist.visibility == 0
        or right_shoulder.visibility == 0
        or left_shoulder.visibility == 0
        or right_hip.visibility == 0
        or left_hip.visibility == 0
    ):
        return tuple([player_number, player_move])

    if (
        abs(right_wrist.x - human_center_x) > TORSO_LENGTH_ARM_RATIO * torso_length
        or abs(left_wrist.x - human_center_x) > TORSO_LENGTH_ARM_RATIO * torso_length
    ):
        
        player_move = "Attack"
        
        if (
            right_wrist.y < (right_hip.y - (TORSO_LENGTH_ARM_RATIO * torso_length))
            and abs(left_wrist.x - human_center_x) > TORSO_LENGTH_ARM_RATIO * torso_length
        ) or (
            left_wrist.y < (left_hip.y - (TORSO_LENGTH_ARM_RATIO * torso_length))
            and abs(right_wrist.x - human_center_x) > TORSO_LENGTH_ARM_RATIO * torso_length
        ):
            player_move = "Special Attack"

    elif (
        right_wrist.y < (right_hip.y - (0.2 * torso_length))
        and right_wrist.y > right_shoulder.y
    ) or (
        left_wrist.y < (left_hip.y - (0.2 * torso_length))
        and left_wrist.y > left_shoulder.y
    ):
        player_move = "Defending"

    elif right_wrist.y < (right_shoulder.y + 0.15 * torso_length) or left_wrist.y < (
        left_shoulder.y + 0.15 * torso_length
    ):
        player_move = "Healing"
    print(tuple([player_number, player_move]))
    return tuple([player_number, player_move])


options = vision.PoseLandmarkerOptions(
    base_options=python.BaseOptions(model_asset_path=MODEL_PATH),
    running_mode=vision.RunningMode.LIVE_STREAM,
    num_poses=NUM_POSES,
    min_pose_detection_confidence=MIN_DETECTION_CONFIDENCE,
    min_pose_presence_confidence=MIN_PRESENCE_CONFIDENCE,
    min_tracking_confidence=MIN_TRACKING_CONFIDENCE,
    output_segmentation_masks=True,
    result_callback=print_result,
)


def draw_landmarks_on_image(rgb_image, detection_result):
    if (rgb_image is None) or (detection_result is None):
        return

    pose_object_list = detection_result.pose_landmarks
    annotated_image = rgb_image.copy()

    # Loop through the detected poses to visualize.
    for idx in range(len(pose_object_list)):
        pose_landmarks = pose_object_list[idx]

        pose_landmarks_proto = landmark_pb2.NormalizedLandmarkList()
        pose_landmarks_proto.landmark.extend(
            [
                landmark_pb2.NormalizedLandmark(
                    x=landmark.x, y=landmark.y, z=landmark.z
                )
                for landmark in pose_landmarks
            ]
        )
        mp.solutions.drawing_utils.draw_landmarks(
            annotated_image,
            pose_landmarks_proto,
            mp.solutions.pose.POSE_CONNECTIONS,
            mp.solutions.drawing_styles.get_default_pose_landmarks_style(),
        )

        if True:  # ! Disable for production
            nose_pose = pose_landmarks[mp.solutions.pose.PoseLandmark.NOSE]
            action = define_action(pose_landmarks)

            cv2.putText(
                annotated_image,
                f"Player {action[0]}: {action[1]}",
                (
                    int(nose_pose.x * WIDTH),
                    int(nose_pose.y * HEIGHT),
                ),
                cv2.FONT_HERSHEY_SIMPLEX,
                1,
                (255, 255, 255),
                2,
                cv2.LINE_AA,
            )

            left_wrist = pose_landmarks[mp.solutions.pose.PoseLandmark.LEFT_WRIST]
            right_wrist = pose_landmarks[mp.solutions.pose.PoseLandmark.RIGHT_WRIST]

            if left_wrist.visibility > MIN_TRACKING_CONFIDENCE:
                cv2.putText(
                    annotated_image,
                    "Left wrist",
                    (
                        int(left_wrist.x * WIDTH),
                        int(left_wrist.y * HEIGHT),
                    ),
                    cv2.FONT_HERSHEY_SIMPLEX,
                    1,
                    (0, 255, 0),
                    2,
                    cv2.LINE_AA,
                )

            if right_wrist.visibility > MIN_TRACKING_CONFIDENCE:
                cv2.putText(
                    annotated_image,
                    "Right wrist",
                    (
                        int(right_wrist.x * WIDTH),
                        int(right_wrist.y * HEIGHT),
                    ),
                    cv2.FONT_HERSHEY_SIMPLEX,
                    1,
                    (0, 0, 255),
                    2,
                    cv2.LINE_AA,
                )

    return annotated_image


def scan(seconds, solo_play):
    global SOLO_PLAY
    
    pygame.init()
    cap = cv2.VideoCapture(0)
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, WIDTH)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, HEIGHT)
    screen = pygame.display.get_surface()
    if screen is None:
        screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.FULLSCREEN)    
        pygame.display.set_caption("WizViz Pose Detection")


    def timer_callback():
        nonlocal running
        running = False

    timer = threading.Timer(seconds, timer_callback)
    timer.start()

    if solo_play:
        SOLO_PLAY = True
    p1_actions = [0, 0, 0, 0, 0]
    """[Resting, Defending, Attacking, Healing, Special Attack]"""
    p2_actions = [0, 0, 0, 0, 0]
    """[Resting, Defending, Attacking, Healing, Special Attack]"""

    actions = ["Resting", "Defending", "Attacking", "Healing", "Special Attack"]

    with vision.PoseLandmarker.create_from_options(options) as landmarker:
        global to_window
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    running = False

            ret, frame = cap.read()
            if not ret:
                break

            rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            mp_image = mp.Image(image_format=mp.ImageFormat.SRGB, data=rgb_frame)
            timestamp_ms = int(cv2.getTickCount() / cv2.getTickFrequency() * 1000)

            landmarker.detect_async(mp_image, timestamp_ms)

            if detection_result is not None:
                for pose_landmarks in detection_result.pose_landmarks:
                    action = define_action(pose_landmarks)
                    # print(f"Player {action[0]}: {action[1]}")
                    if action[0] == 1:
                        if action[1] == "Resting":
                            p1_actions[0] += 1
                        elif action[1] == "Defending":
                            p1_actions[1] += 1
                        elif action[1] == "Attacking":
                            p1_actions[2] += 1
                        elif action[1] == "Healing":
                            p1_actions[3] += 1
                        else:
                            p1_actions[4] += 1
                    elif action[0] == 2:
                        if action[1] == "Resting":
                            p2_actions[0] += 1
                        elif action[1] == "Defending":
                            p2_actions[1] += 1
                        elif action[1] == "Attacking":
                            p2_actions[2] += 1
                        elif action[1] == "Healing":
                            p2_actions[3] += 1
                        else:
                            p2_actions[4] += 1
                    else:
                        continue

            if to_window is not None:
                # Flip the frame horizontally
                flip_frame = cv2.flip(to_window, 1)
                # Rotate the frame 270 degrees
                frame_rotated = cv2.rotate(flip_frame, cv2.ROTATE_90_COUNTERCLOCKWISE)
                # Convert the frame from BGR to RGB (Pygame uses RGB)
                frame_rgb = cv2.cvtColor(frame_rotated, cv2.COLOR_BGR2RGB)
                # Convert the frame to a Pygame surface
                frame_surface = pygame.surfarray.make_surface(frame_rgb)
                # Display the surface on the Pygame screen
                screen.blit(frame_surface, (0, 0))

                pygame.display.flip()

            if cv2.waitKey(1) & 0xFF == ord("q"):
                break

        cap.release()
        # pygame.display.quit()
        
    max_action_index_p1 = np.argmax(p1_actions)
    max_action_index_p2 = np.argmax(p2_actions)
    if (SOLO_PLAY):
        return actions[max_action_index_p1]
    
    else:
        return tuple([actions[max_action_index_p1], actions[max_action_index_p2]])

# print(scan(5, True))

================
File: src/main.py
================
import pygame
import yaml
import sys
import os
import Player_List
import random


# Load game options from YAML file, defaults are preset if yaml is errored
def load_options():
    try:
        yaml_path = os.path.join(os.path.dirname(__file__), "../properties.yaml")
        with open(yaml_path, "r") as file:
            return yaml.safe_load(file)
    except FileNotFoundError:
        return {
            "base_options": {
                "mode": "two_player",
                "debug_mode": False,
                "splitscreen": False,
                "skeleton": False,
                "difficulty": 2,  # Ensure difficulty is included here
            },
            "game_options": {"ai": {"attack": 0, "health": 0, "mana": 0}},
        }


# Save game options to YAML file
def save_options(options):
    yaml_path = os.path.join(os.path.dirname(__file__), "../properties.yaml")
    with open(yaml_path, "w") as file:
        yaml.dump(options, file)


# Initialize Pygame
pygame.init()

# Screen dimensions
SCREEN_WIDTH, SCREEN_HEIGHT = 1920, 1080  # Init heights, can change to 1020x1080rez
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.FULLSCREEN)
pygame.display.set_caption("WizViz")

# Colors
WHITE, BLACK, GRAY, LIGHT_GRAY = (
    (255, 255, 255),
    (0, 0, 0),
    (200, 200, 200),
    (220, 220, 220),
)
BLUE, LIGHT_BLUE, DARK_GRAY, GREEN, RED = (
    (0, 0, 255),
    (173, 216, 230),
    (50, 50, 50),
    (0, 255, 0),
    (255, 0, 0),
)

# Fonts
FONT, TITLE_FONT, TOOLTIP_FONT = (
    pygame.font.Font(None, 36),
    pygame.font.Font(None, 120),
    pygame.font.Font(None, 24),
)

# Load options
options = load_options()
print(options)


# Button class for UI
def draw_button(text, x, y, width, height, color, hover_color, mouse_pos):
    rect = pygame.Rect(x, y, width, height)
    pygame.draw.rect(
        screen,
        hover_color if rect.collidepoint(mouse_pos) else color,
        rect,
        border_radius=10,
    )
    text_surface = FONT.render(text, True, BLACK)
    screen.blit(text_surface, text_surface.get_rect(center=rect.center))
    return rect


# Main menu
def main_menu():
    running = True
    background_image = pygame.image.load(r"src/background.png").convert()
    screen_width, screen_height = screen.get_size()
    #background_image = pygame.transform.scale(background_image, (1368, 720))
    a = pygame.transform.scale(background_image, (screen_width, screen_height))
    pygame.display.flip()
    
    while running:
        #screen.fill(WHITE)
        screen.blit(a, (0, 0))
        mouse_pos = pygame.mouse.get_pos()

        title_text = TITLE_FONT.render("WizViz", True, DARK_GRAY)
        screen.blit(title_text, (SCREEN_WIDTH // 2 - title_text.get_width() // 2, (SCREEN_HEIGHT / 6)))

        buttons = {
            "Play": draw_button("Play", ((SCREEN_WIDTH - 300) // 2), (2 * SCREEN_HEIGHT / 6), 300, 75, GRAY, LIGHT_BLUE, mouse_pos),
            "Options": draw_button(
                "Options", ((SCREEN_WIDTH - 300) // 2), (3 * SCREEN_HEIGHT / 6), 300, 75, GRAY, LIGHT_BLUE, mouse_pos
            ),
            "Quit": draw_button("Quit", ((SCREEN_WIDTH - 300) // 2), (4 * SCREEN_HEIGHT / 6), 300, 75, GRAY, LIGHT_BLUE, mouse_pos),
        }

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttons["Play"].collidepoint(event.pos):
                    start_game()  # Start game, ideally close this one after the next file starts
                elif buttons["Options"].collidepoint(event.pos):
                    options_menu()
                elif buttons["Quit"].collidepoint(event.pos):
                    pygame.quit()
                    sys.exit()

        pygame.display.flip()


# Options menu
def options_menu():
    running = True
    var = True
    background_image = pygame.image.load(r"src/background.png").convert()
    screen_width, screen_height = screen.get_size()
    #background_image = pygame.transform.scale(background_image, (1368, 720))
    a = pygame.transform.scale(background_image, (screen_width, screen_height))
    while running:
        #screen.fill(WHITE)
        screen.blit(a, (0, 0))
        mouse_pos = pygame.mouse.get_pos()
        
        y_offset = 3
        
        title_text = TITLE_FONT.render("Options", True, DARK_GRAY)
        screen.blit(title_text, (SCREEN_WIDTH // 2 - title_text.get_width() // 2, (SCREEN_HEIGHT / 12)))

        option_keys = list(options["base_options"].keys())
        if var:
            print(option_keys)
            var = not var

        option_rects = {}

        for key in option_keys:
            # Handling 'difficulty' separately since it's a number
            if key == "difficulty":
                option_text = f"{key.capitalize()}: {options['base_options'][key]}"
                option_rects[key] = draw_button(
                    option_text, ((SCREEN_WIDTH - 400) // 2), (y_offset * SCREEN_HEIGHT // 12), 400, 50, GRAY, LIGHT_BLUE, mouse_pos
                )
                y_offset += 1
            else:
                option_text = f"{key.capitalize()}: {options['base_options'][key]}"
                option_rects[key] = draw_button(
                    option_text, ((SCREEN_WIDTH - 400) // 2), (y_offset * SCREEN_HEIGHT // 12), 400, 50, GRAY, LIGHT_BLUE, mouse_pos
                )
                y_offset += 1

        ai_keys = list(options["game_options"]["ai"].keys())
        for key in ai_keys:
            option_text = f"AI {key.capitalize()}: {options['game_options']['ai'][key]}"
            option_rects[key] = draw_button(
                option_text, ((SCREEN_WIDTH - 400) // 2), (y_offset * SCREEN_HEIGHT // 12), 400, 50, GRAY, LIGHT_BLUE, mouse_pos
            )
            y_offset += 1

        buttons = {
            "Save": draw_button(
                "Save",
                ((SCREEN_WIDTH - 175) // 2 + 112.5),
                (y_offset * SCREEN_HEIGHT // 12),
                175,
                50,
                GREEN,
                LIGHT_BLUE,
                mouse_pos,
            ),
            "Back": draw_button(
                "Back",
                ((SCREEN_WIDTH - 175) // 2 - 112.5),
                (y_offset * SCREEN_HEIGHT // 12),
                175,
                50,
                RED,
                LIGHT_BLUE,
                mouse_pos,
            ),
        }

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                for key, rect in option_rects.items():
                    if rect.collidepoint(event.pos):
                        if key in options["base_options"]:
                            if isinstance(options["base_options"][key], bool):
                                options["base_options"][key] = not options[
                                    "base_options"
                                ][key]
                            elif key == "mode":
                                options["base_options"][key] = (
                                    "player_vs_ai"
                                    if options["base_options"][key] == "two_player"
                                    else "two_player"
                                )
                            elif key == "difficulty":
                                # For 'difficulty', let the user change the difficultyiculty
                                options["base_options"][key] = (
                                    options["base_options"][key] % 5
                                ) + 1  # Toggle between 1, 2, 3 for difficulty
                        elif key in options["game_options"]["ai"]:
                            options["game_options"]["ai"][key] += (
                                1  # Increment AI options for simplicity
                            )
                if buttons["Save"].collidepoint(event.pos):
                    save_options(options)
                    running = False
                elif buttons["Back"].collidepoint(event.pos):
                    running = False

        pygame.display.flip()


# Start game
def start_game():
    single_player = options["base_options"]["mode"] == "player_vs_ai"

    def select_player_menu(player_num):
        running = True
        selected_player = None
        players = [
            Player_List.Draco(),
            Player_List.Hydra(),
            Player_List.Phoenix(),
            Player_List.Lyra(),
            Player_List.Orion(),
            Player_List.Pegasus(),
            Player_List.Andromeda(),
            Player_List.Centaurus(),
            Player_List.Cassiopeia(),
        ]
        player_names = [player.get_name() for player in players]

        background_image = pygame.image.load(r"src/background.png").convert()
        screen_width, screen_height = screen.get_size()
        #background_image = pygame.transform.scale(background_image, (1368, 720))
        a = pygame.transform.scale(background_image, (screen_width, screen_height))
        while running:
        #screen.fill(WHITE)
            screen.blit(a, (0, 0))
            #screen.fill(WHITE)
            mouse_pos = pygame.mouse.get_pos()

            y_offset = 1

            title_text = TITLE_FONT.render(
                f"Select Player {player_num}", True, DARK_GRAY
            )
            screen.blit(
                title_text, (((SCREEN_WIDTH - title_text.get_width()) // 2), ((y_offset * SCREEN_HEIGHT) / 15))
            )
            y_offset += 1.5

            player_rects = {}

            for name in player_names:
                player_rects[name] = draw_button(
                    name, ((SCREEN_WIDTH - 400) // 2), ((y_offset * SCREEN_HEIGHT) / 15), 400, 50, GRAY, LIGHT_BLUE, mouse_pos
                )
                y_offset += 1

            cancel_button = draw_button(
                "Cancel", ((SCREEN_WIDTH - 400) // 2), ((y_offset * SCREEN_HEIGHT) / 15), 400, 50, RED, LIGHT_BLUE, mouse_pos
            )
            y_offset += 1

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    for name, rect in player_rects.items():
                        if rect.collidepoint(event.pos):
                            selected_player = name
                            running = False
                    if cancel_button.collidepoint(event.pos):
                        running = False
                        main_menu()

            pygame.display.flip()

        return selected_player

    def ai_select(player1):
        players = [
            Player_List.Draco(),
            Player_List.Hydra(),
            Player_List.Phoenix(),
            Player_List.Lyra(),
            Player_List.Orion(),
            Player_List.Pegasus(),
            Player_List.Andromeda(),
            Player_List.Centaurus(),
            Player_List.Cassiopeia(),
        ]
        player_names = [
            player.get_name() for player in players if player.get_name() != player1
        ]
        selected_player = random.choice(player_names)
        return selected_player

    player1 = select_player_menu(1)
    options["game_options"]["player1"] = {"name": player1}
    save_options(options)

    if single_player:
        player2 = ai_select(player1)
    else:
        player2 = select_player_menu(2)

    options["game_options"]["player2"] = {"name": player2}
    save_options(options)

    def countdown():
        for i in range(3, 0, -1):
            #screen.fill(WHITE)
            countdown_text = TITLE_FONT.render(str(i), True, DARK_GRAY)
            screen.blit(
                countdown_text,
                (
                    SCREEN_WIDTH // 2 - countdown_text.get_width() // 2,
                    SCREEN_HEIGHT // 2 - countdown_text.get_height() // 2,
                ),
            )
            pygame.display.flip()
            pygame.time.delay(1000)

    countdown()
    import engine

    if __name__ == "__main__":
        engine.run()


# Run main menu
main_menu()
pygame.quit()

================
File: src/particles.py
================
import random 
import pygame

class Particle:
    def __init__(self, pos, velocity, color, size, lifespan):
        self.pos = list(pos)
        self.velocity = velocity
        self.color = color
        self.size = size
        self.lifespan = lifespan
        self.age = 0

    def update(self):
        self.pos[0] += self.velocity[0]
        self.pos[1] += self.velocity[1]
        self.age += 1
        self.size = max(0, self.size - 0.1)  

    def is_dead(self):
        return self.age >= self.lifespan or self.size <= 0

    def draw(self, surface):
        if self.size > 0:
            pygame.draw.circle(surface, self.color, (int(self.pos[0]), int(self.pos[1])), int(self.size))


class ParticleEffect:
    def __init__(self, pos, target_pos, num_particles, color, max_lifespan=30):
        self.particles = [
            Particle(
                pos=pos,
                velocity=(
                    random.uniform((target_pos[0] - pos[0]) * 0.01, (target_pos[0] - pos[0]) * 0.02),
                    random.uniform((target_pos[1] - pos[1]) * 0.01, (target_pos[1] - pos[1]) * 0.02),
                ),
                color=color,
                size=random.uniform(3, 6),
                lifespan=random.randint(max_lifespan // 2, max_lifespan)
            )
            for _ in range(num_particles)
        ]

    def update(self):
        self.particles = [particle for particle in self.particles if not particle.is_dead()]
        for particle in self.particles:
            particle.update()

    def draw(self, surface):
        for particle in self.particles:
            particle.draw(surface)

================
File: src/Player_List.py
================
from Player import Player

class Draco(Player):
    def __init__(self):
        super().__init__("Draco", health=120, attack=25, defense=5, special_attack_name="Fireball", special_attack_damage=35)

class Hydra(Player):
    def __init__(self):
        super().__init__("Hydra", health=140, attack=30, defense=1, special_attack_name="Venom", special_attack_damage=35)

class Phoenix(Player):
    def __init__(self):
        super().__init__("Phoenix", health=160, attack=15, defense=25, special_attack_name="Rebirth", special_attack_damage=45)

class Lyra(Player):
    def __init__(self):
        super().__init__("Lyra", health=60, attack=40, defense=20, special_attack_name="Heal", special_attack_damage=50)

class Orion(Player):
    def __init__(self):
        super().__init__("Orion", health=110, attack=28, defense=8, special_attack_name="Arrow Storm", special_attack_damage=38)

class Pegasus(Player):
    def __init__(self):
        super().__init__("Pegasus", health=90, attack=32, defense=12, special_attack_name="Wing Slash", special_attack_damage=42)

class Andromeda(Player):
    def __init__(self):
        super().__init__("Andromeda", health=70, attack=37, defense=17, special_attack_name="Chain Strike", special_attack_damage=47)

class Centaurus(Player):
    def __init__(self):
        super().__init__("Centaurus", health=85, attack=33, defense=13, special_attack_name="Trample", special_attack_damage=43)

class Cassiopeia(Player):
    def __init__(self):
        super().__init__("Cassiopeia", health=75, attack=36, defense=18, special_attack_name="Poison Fang", special_attack_damage=46)

================
File: src/Player.py
================
import random

class Player:
    def __init__(self, name, health, attack, defense, special_attack_name, special_attack_damage):
        self.name = name
        self.health = health
        self.attack = attack
        self.mana = random.randint(80, 120)
        self.defense = defense
        self.special_attack_name = special_attack_name
        self.special_attack_damage = special_attack_damage

        if self.mana < 100:
            self.special_attack_damage *= 1.25

    def get_name(self):
        return self.name
    
    def set_name(self, name):
        self.name = name

    def get_attack(self):
        return self.attack
    
    def set_attack(self, attack):
        self.attack = attack
    
    def get_defense(self):
        return self.defense
    
    def set_defense(self, defense):
        self.defense = defense
    
    def get_special_attack_name(self):
        return self.special_attack_name
    
    def set_special_attack_name(self, special_attack_name):
        self.special_attack_name = special_attack_name
    
    def get_special_attack_damage(self):
        return self.special_attack_damage
    
    def set_special_attack_damage(self, special_attack_damage):
        self.special_attack_damage = special_attack_damage

    def get_health(self):
        return self.health

    def set_health(self, health):
        self.health = health

    def get_mana(self):
        return self.mana
    
    def set_mana(self, mana):
        self.mana = mana

================
File: src/sounds.py
================
import pygame

class SoundManager:
    def __init__(self):
        pygame.mixer.init()
        self.sounds = {
            'Attack': pygame.mixer.Sound('src/sounds/attack.wav'),
            'Heal': pygame.mixer.Sound('src/sounds/heal.wav'),
            'Special': pygame.mixer.Sound('src/sounds/special.mp3')
        }
        
    def play_sound(self, action):
        if action in self.sounds:
            self.sounds[action].play()

================
File: src/spritesheet.py
================
import pygame

class SpriteManager:
    def __init__(self):
        self.sprite_sheet = pygame.image.load('spritesheet.png').convert_alpha()
        self.character_sprites = {
            'Centaurus': {'x': 0, 'y': 0},
            'Pegasus': {'x': 0, 'y': 1},
            'Phoenix': {'x': 0, 'y': 2},
            'Dragon': {'x': 0, 'y': 3}
        }
        self.sprite_size = 24  # Size of each sprite frame
        
    def get_sprite(self, character_name, action):
        if character_name not in self.character_sprites:
            return None
            
        char_pos = self.character_sprites[character_name]
        action_frames = {
            'Idle': 0,
            'Attack': 1,
            'Defend': 2,
            'Special': 3
        }
        
        x = char_pos['x'] + (action_frames.get(action, 0) * self.sprite_size)
        y = char_pos['y'] * self.sprite_size
        
        sprite = pygame.Surface((self.sprite_size, self.sprite_size), pygame.SRCALPHA)
        sprite.blit(self.sprite_sheet, (0, 0), (x, y, self.sprite_size, self.sprite_size))
        return pygame.transform.scale(sprite, (72, 72))  # Scale up for display

================
File: .gitignore
================
env/
__pycache__/

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Knivier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: properties.yaml
================
base_options:
  debug_mode: true
  difficulty: 5
  mode: player_vs_ai
  skeleton: true
  splitscreen: true
game_options:
  ai:
    attack: 80
    health: 40
    mana: 5
  player1:
    name: Draco
  player2:
    name: Andromeda
temp_game_options:
  player1: ''
  player2: ''

================
File: README.md
================
# SpartaX
undecided project

================
File: requirements.txt
================
pygame
PyYAML
opencv-python
mediapipe
numpy
setuptools
wheel
